# @title Ruby AMQP gem: Working with queues

h1. Working with queues


h2. About this guide

This guide covers everything related to queues in AMQP 0.9.1, common usage scenarios and how to accomplish typical operations using
amqp gem.


h2. Covered versions

This guide covers "Ruby amqp gem":http://github.com/ruby-amqp/amqp v0.8.0 and later.



h2. Queues in AMQP 0.9.1, briefly

h3. What are AMQP queues?

Queues store and forward messages to consumers. They are similar to mailboxes in SMTP.
Messages flow from producing applications to {file:docs/Exchanges.textile exchanges} that route them
to queues and finally queues deliver them to consumer applications (or consumer applications fetch messages as needed).

Note that unlike some other messaging protocols/systems, messages are not delivered directly
to queues. They are delivered to exchanges that route messages to queues using rules
knows as *bindings*.

AMQP is a programmable protocol, so queues and bindings alike are declared by applications.


h3. Concept of bindings

Binding is an association between a queue and an exchange. Queues must be bound to at least one exchange in order to receive messages from publishers.
Learn more about bindings in {file:docs/Bindings.textile Bindings guide}.


h3. Attributes

Queues have several attributes associated with them:

 * Name
 * Exclusivity
 * Durability
 * Whether queue is auto-deleted when no longer used
 * Other metadata (aka X-arguments)

These attributes define how queues can be used, what their lifecycle is like and other aspects of queue
behavior.

amqp gem represents queues as instances of {AMQP::Queue}.


h2. Queue names. Declaring queues.

Every AMQP queue has a name that identifies it. Queue names often contain several segments separated by a dot (.), similarly to how URI
path segments are separated by a slash (/), although it may be almost any string, with some limitations (see below).

Before queue can be used, it has to be *declared*. Declaring a queue will create it if it doesn't exist, or have no effect if it does
and attributes are the same. When attributes are not the same, channel-level exception is raised. This case is covered later in this
guide.

h3. Explicitly named queues

Applications may pick queue names or ask broker to generate a name for them.

To declare a queue with a particular name, for example, "images.resize", pass it to Queue class constructor:

<pre>
<code>
queue = AMQP::Queue.new(channel, "images.resize", :auto_delete => true)
</code>
</pre>

Full example:
<script src="https://gist.github.com/998721.js"> </script>


h3. Server-named queues.

To ask AMQP broker generate unique queue name for you, pass *empty string* as queue name argument:

<pre>
<code>
AMQP::Queue.new(channel, "", :auto_delete => true) do |queue, declare_ok|
  puts "#{queue.name} is ready to go. AMQP method: #{declare_ok.inspect}"
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/998720.js"> </script>

amqp gem allows server-named queues to be declared without callbacks:

<pre>
<code>
queue = AMQP::Queue.new(channel, "", :auto_delete => true)
</code>
</pre>

In this case, as soon as AMQP broker reply (`queue.declar-ok` AMQP method) arrives, queue object name will be assigned
to the value broker had generated. Because many AMQP operations require queue name, before {AMQP::Queue} instance receives
its name, those operations are delayed. This example demonstrates this:

<pre>
<code>
queue = channel.queue("")
queue.bind("builds").subscribe do |metadata, payload|
  # message handling implementation...
end
</code>
</pre>

In this example, binding will be performed as soon as queue had received its name generated by the broker.
If particular piece of code relies on queue name being available immediately, callback use is required.


h3. Reserved queue name prefix.

Queue names starting with 'amq.' are reserved for internal use by the broker. Attempts to declare queue with a name that violates this
rule will result in a channel-level exception with reply code 403 (ACCESS_REFUSED) and reply message similar to this:

<pre>ACCESS_REFUSED - queue name 'amq.queue' contains reserved prefix 'amq.*'</pre>


h3. Queue re-declaration with different attributes.

When attributes are different from what queue already has, channel-level exception with code 406
(PRECONDITION_FAILED) will be raised. Reply text will be similar to this:

<pre>PRECONDITION_FAILED - parameters for queue 'amqpgem.examples.channel_exception' in vhost '/' not equivalent</pre>



h2. Queue life-cycle patterns.

To quote AMQP 0.9.1 spec, there are two common message queue life-cycle patterns:

 * Durable message queues that are shared by many consumers and have an independent existence: i.e. they
   will continue to exist and collect messages whether or not there are consumers to receive them.
 * Temporary message queues that are private to one consumer and are tied to that consumer. When the
   consumer disconnects, the message queue is deleted.

There are some variations of these, such as shared message queues that are deleted when the last of
many consumers disconnects.

One example of durable message queues is well-known services like event collectors (event loggers).
They are usually up whether there are services to log anything or not. Other applications know what
queues they use and can rely on those queues being around all the time, survive broker restarts and
in general be available should an application in the network need to use them. In this case,
explicitly named durable queues are optimal and coupling it creates between applications is not
an issue. Another scenario of a well-known long-lived service is distributed metadata/directory/locking server
like Apache Zookeeper, Google's Chubby or DNS. Services like this benefit from using well-known, not generated
queue names, and so do other applications that use them.

Different scenario is in "a cloud settings" when some kind of workers/instances may come online and
go down basically any time and other applications cannot rely on them being available. Using well-known
queue names in this case is possible but server-generated, short-lived queues that are bound to
topic or fanout exchanges to receive relevant messages is a better idea.

Imagine a service that processes an endless stream of events (Twitter is one example). When traffic goes
up, development operations may spin up additional applications instances in the cloud to handle the load.
Those new instances want to subscribe to receive messages to process but the rest of the system doesn't
know anything about them, rely on them being online or try to address them directly: they process events
from a shared stream and are not different from their peers. In a case like this, there is no reason for
message consumers to not use queue names generated by the broker.

In general, use of explicitly named or server-named queues depends on messaging pattern your application needs.
{http://www.eaipatterns.com/ Enterprise Integration Patters} discusses many messaging patterns in depth.
RabbitMQ FAQ also has a section on {http://www.rabbitmq.com/faq.html#scenarios use cases}.



h2. Declaring a durable shared queue

To declare a durable shared queue, you pass queue name that is a non-blank string and use :durable option:

<pre>
<code>
queue = AMQP::Queue.new(channel, "images.resize", :durable => true)
</code>
</pre>

Full example:
<script src="https://gist.github.com/998723.js"> </script>

the same example rewritten to use {AMQP::Channel#queue}:

<pre>
<code>
channel.queue("images.resize", :durable => true) do |queue, declare_ok|
  puts "#{queue.name} is ready to go."
end
</code>
</pre>

<script src="https://gist.github.com/998724.js"> </script>



h2. Declaring a temporary exclusive queue

To declare a server-named, exclusive, auto-deleted queue, pass "" (empty string) as queue name and
use :exclusive and :auto_delete options:

<pre>
<code>
AMQP::Queue.new(channel, "", :auto_delete => true, :exclusive => true) do |queue, declare_ok|
  puts "#{queue.name} is ready to go."
end
</code>
</pre>

Full example:

<script src="https://gist.github.com/998725.js"> </script>

The same example can rewritten to use {AMQP::Channel#queue}:

<pre>
<code>
channel.queue("", :auto_delete => true, :exclusive => true) do |queue, declare_ok|
  puts "#{queue.name} is ready to go."
end
</code>
</pre>

Full example:

<script src="https://gist.github.com/998726.js"> </script>

Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.
Declaration of an exclusive queue by other connections are not allowed and will result in a channel-level exception
with the code 405 (RESOURCE_LOCKED) and reply message similar to

<pre>RESOURCE_LOCKED - cannot obtain exclusive access to locked queue 'amqpgem.examples.queue' in vhost '/'</pre>

The following example demonstrates this:
<script src="https://gist.github.com/1008529.js"> </script>



h2. Binding queues to exchanges

In order to receive messages, a queue needs to be bound to at least one exchange. Most of the time binding is explcit (done by applications).
To bind a queue to an exchange, use {AMQP::Queue#bind}. Argument can be either an {AMQP::Exchange} instance or a string.

<pre>
<code>
queue.bind(exchange) do |bind_ok|
  puts "Just bound #{queue.name} to #{exchange.name}"
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/998727.js"> </script>

Same example using a string and without callback:

<pre>
<code>
queue.bind("amq.fanout")
</code>
</pre>

Full example:
<script src="https://gist.github.com/998729.js"> </script>




h2. Subscribing to receive messages ("push API")

To subscribe to receive messages when they arrive to the queue ("start a queue consumer"), one uses {AMQP::Queue#subscribe} method.
Then when a message arrives, message metadata (aka header, aka envelope) and body (aka payload) are passed to the handler:

<pre>
<code>
queue.subscribe do |metadata, payload|
  puts "Received a message: #{payload.inspect}."
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/998731.js"> </script>

Subscriptions for message delivery are usually referred to as "consumers" in the AMQP 0.9.1 spec, client libraries documentation and books.
Consumers last as long as the channel they were declared on, or until the client cancels them (unsubscribes).

Consumers are identified by <i>consumer tags</i>. If you need to obtain consumer tag of a queue that is subscribed to receive messages,
use {AMQP::Queue#consumer_tag}.


h3. Accessing message metadata

`header` object in the example above provides access to message metadata and delivery information:

 * Message content type
 * Message content­encoding
 * Message routing key
 * Message delivery mode (persistent or not)
 * Consumer tag this delivery is for
 * Delivery tag
 * Message priority
 * Whether or not message is redelivered
 * Producer application id

and so on. An example to demonstrate how to access some of those attributes:

<pre>
<code>
# producer
exchange.publish("Hello, world!",
                 :app_id      => "amqpgem.example",
                 :priority    => 8,
                 :type        => "kinda.checkin",
                 # headers table keys can be anything
                 :headers     => {
                   :coordinates => {
                     :latitude  => 59.35,
                     :longitude => 18.066667
                   },
                   :participants => 11,
                   :venue        => "Stockholm"
                 },
                 :timestamp   => Time.now.to_i)
</code>
</pre>

<pre>
<code>
# consumer
queue.subscribe do |metadata, payload|
  puts "metadata.routing_key : #{metadata.routing_key}"
  puts "metadata.content_type: #{metadata.content_type}"
  puts "metadata.priority    : #{metadata.priority}"
  puts "metadata.headers     : #{metadata.headers.inspect}"
  puts "metadata.timestamp   : #{metadata.timestamp.inspect}"
  puts "metadata.type        : #{metadata.type}"
  puts "metadata.delivery_tag: #{metadata.delivery_tag}"
  puts "metadata.redelivered : #{metadata.redelivered?}"

  puts "metadata.app_id      : #{metadata.app_id}"
  puts "metadata.exchange    : #{metadata.exchange}"
  puts
  puts "Received a message: #{payload}."
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/998739.js"> </script>


h3. Exclusive consumers

Consumers can request exclusive access to the queue (meaning only this consumer can access the queue). This is useful when you want a long-lived shared
queue to be temporarily accessible by just one application (or thread, or process). If application exclusive consumer is part of crashes or loses
TCP connection to the broker, channel is closed and exclusive consumer is thus cancelled.

To exclusively receive messages from the queue, pass :exclusive option to {AMQP::Queue#subscribe}:

<pre>
<code>
queue.subscribe(:exclusive => true) do |metadata, payload|
  # message handling logic...
end
</code>
</pre>

TBD: describe what happens when exclusivity property is violated and how to handle it.


h3. Using multiple consumers per queue

Historically, amqp gem versions before 0.8.0.RC14 (currently master branch in the repository) have had a "one consumer per Queue instance"
limitation. Previously to work around this problem, application developers had to open multiple channels and work with multiple queue
instances on different channels. This is not very convenient and is surprising for developers familiar with AMQP clients for
other languages.

With more and more Ruby implementations dropping the "GIL":http://en.wikipedia.org/wiki/Global_Interpreter_Lock,
load balancing between multiple consumers in the same queue in the same OS process becomes more and more common. In certain cases,
even applications that do not need any concurrency benefit from having multiple consumers on the same queue in the same process.

Starting from amqp gem version 0.8.0.RC14, it is possible to add any number of consumers by instantiating {AMQP::Consumer} directly:

<pre>
<code>
# non-exclusive consumer, consumer tag is generated
consumer1 = AMQP::Consumer.new(channel, queue)

# non-exclusive consumer, consumer tag is explicitly given
consumer2 = AMQP::Consumer.new(channel, queue, "#{queue.name}-consumer-#{rand}-#{Time.now}")

# exclusive consumer, consumer tag is generated
consumer3 = AMQP::Consumer.new(channel, queue, nil, true)
</code>
</pre>

Instantiated consumers do not begin consuming messages immediately. This is because in certain cases, it is useful to add a consumer but
make it active at a later time. To consume messages, use {AMQP::Consumer#consume} method in combination with {AMQP::Consumer#on_delivery}:

<pre>
<code>
consumer1.consume.on_delivery do |metadata, payload|
  @consumer1_mailbox << payload
end
</code>
</pre>

{AMQP::Consumer#on_delivery} takes a block that is used exactly as {AMQP::Queue#subscribe}. In fact, {AMQP::Queue#subscribe} uses
{AMQP::Consumer} under the hood, adding _default consumer_ to the queue. Default consumers do not have any special properties, they
are just a way to provide application developers a way to register multiple consumers when necessary, while providing a convenient
method that {AMQP::Queue#subscribe} is and preserving backwards compatibility.

<span class="note">
Default consumers do not have any special properties, they are just a mean of convenience and preserving backwards compatibility.
Application developers are free to always use AMQP::Consumer instances directly, or intermix it with AMQP::Queue#subscribe
</span>

Most of public API methods on {AMQP::Consumer} return self so it is possible to use method chaining heavily. An example from
"amqp gem spec suite":https://github.com/ruby-amqp/amqp/tree/master/spec:

<pre>
<code>
consumer1 = AMQP::Consumer.new(@channel, @queue).consume.on_delivery { |metadata, payload| mailbox1 << payload }
consumer2 = AMQP::Consumer.new(@channel, @queue).consume.on_delivery { |metadata, payload| mailbox2 << payload }
</code>
</pre>

To cancel a particular consumer, use {AMQP::Consumer#cancel} method. To cancel default queue consumer, use {AMQP::Queue#unsubscribe}.


h3. Message acknowledgements

Consumer applications (applications that receive and process messages) may (and will) occasionally fail to process individual messages, or will just
crash. That's not to mention possible network issues. This raises a question: when should AMQP broker remove messages from queues?  AMQP 0.9.1 lets
you choose one of two answers:

 * After broker sends a message to an application (using either basic.deliver or basic.get-ok methods).
 * After the application sends back an acknowledgement (using basic.ack AMQP method).

The former model is called *automatic acknowledgement model* while the latter is *explicit acknowledgement model*. With the explicit model, application
chooses when it's time to send an ack: it can be right after receiving it, or after persisting it to a data store before processing, or after fully
processing the message (for example, successfully fetching a Web page, processing and storing it into some persistent data store).

If a consumer dies without sending an ack, AMQP broker will redeliver it to another consumer (or, if none are available at the time, it will wait
until at least one consumer is registered for the same queue).

Acknowledgement model is chosen when a new consumer is registered for a queue. By default, {AMQP::Queue#subscribe} will use the *automatic* model.
To switch to the *explicit* model, :ack option should be used:

<pre>
<code>
queue.subscribe(:ack => true) do |metadata, payload|
  # message handling logic...
end
</code>
</pre>

To demonstrate how redelivery works, lets have a look at the following code example:

<script src="https://gist.github.com/999396.js"> </script>

So what is going on here? This example uses 3 AMQP connections to imitate 3 applications, 1 producer and two consumers. Each AMQP connection opens a single
channel:

<pre>
<code>
# open two connections to imitate two apps
connection1 = AMQP.connect
connection2 = AMQP.connect
connection3 = AMQP.connect

channel_exception_handler = Proc.new { |ch, channel_close| EventMachine.stop; raise "channel error: #{channel_close.reply_text}" }

# open two channels
channel1    = AMQP::Channel.new(connection1)
channel1.on_error(&channel_exception_handler)
# ...

channel2    = AMQP::Channel.new(connection2)
channel2.on_error(&channel_exception_handler)
# ...

# app 3 will just publish messages
channel3    = AMQP::Channel.new(connection3)
channel3.on_error(&channel_exception_handler)
</code>
</pre>

Consumers share a queue and producer publishes messages there periodically using `amq.direct` exchange. Both "applications" subscribe to receive messages
using explicit acknowledgement model. AMQP broker by default will send each message to the next consumer, in sequence
(this kind of load balancing is knownas *round-robin*). So some messages will be delivered to consumer #1 and some to consumer #2.

<pre>
<code>
exchange = channel3.direct("amq.direct")

# ...

queue1    = channel1.queue("amqpgem.examples.acknowledgements.explicit", :auto_delete => false)
# purge the queue so that we don't get any redeliveries from previous runs
queue1.purge
queue1.bind(exchange).subscribe(:ack => true) do |metadata, payload|
  # do some work
  sleep(0.2)

  # acknowledge some messages, they will be removed from the queue
  if rand > 0.5
    # FYI: there is a shortcut, metadata.ack
    channel1.acknowledge(metadata.delivery_tag, false)
    puts "[consumer1] Got message ##{metadata.headers['i']}, ack-ed"
  else
    # odd messages are not ack-ed and will remain in the queue for redelivery
    # when app #1 connection is closed (either properly or due to a crash)
    puts "[consumer1] Got message ##{metadata.headers['i']}, SKIPPPED"
  end
end

queue2    = channel2.queue!("amqpgem.examples.acknowledgements.explicit", :auto_delete => false)
queue2.subscribe(:ack => true) do |metadata, payload|
  metadata.ack
  # app 2 always acks messages
  puts "[consumer2] Received #{payload}, redelivered = #{metadata.redelivered}, ack-ed"
end
</code>
</pre>

To demonstrate message redelivery we make consumer #1 randomly select what messages to acknowledge. After 4 seconds we disconnect it (to imitate
a crash). When that happens, AMQP broker redelivers unacknowledged messages to the consumer #2 which acknowledges them unconditionally. After 10 seconds,
this example closes all outstanding connections and exits.

An example output produced by this example:

<pre>
=> Subscribing for messages using explicit acknowledgements model

[consumer2] Received Message #0, redelivered = false, ack-ed
[consumer1] Got message #1, SKIPPPED
[consumer1] Got message #2, SKIPPPED
[consumer1] Got message #3, ack-ed
[consumer2] Received Message #4, redelivered = false, ack-ed
[consumer1] Got message #5, SKIPPPED
[consumer2] Received Message #6, redelivered = false, ack-ed
[consumer2] Received Message #7, redelivered = false, ack-ed
[consumer2] Received Message #8, redelivered = false, ack-ed
[consumer2] Received Message #9, redelivered = false, ack-ed
[consumer2] Received Message #10, redelivered = false, ack-ed
[consumer2] Received Message #11, redelivered = false, ack-ed
----- Connection 1 is now closed (we pretend that it has crashed) -----
[consumer2] Received Message #5, redelivered = true, ack-ed
[consumer2] Received Message #1, redelivered = true, ack-ed
[consumer2] Received Message #2, redelivered = true, ack-ed
[consumer2] Received Message #12, redelivered = false, ack-ed
[consumer2] Received Message #13, redelivered = false, ack-ed
[consumer2] Received Message #14, redelivered = false, ack-ed
[consumer2] Received Message #15, redelivered = false, ack-ed
[consumer2] Received Message #16, redelivered = false, ack-ed
[consumer2] Received Message #17, redelivered = false, ack-ed
[consumer2] Received Message #18, redelivered = false, ack-ed
[consumer2] Received Message #19, redelivered = false, ack-ed
[consumer2] Received Message #20, redelivered = false, ack-ed
[consumer2] Received Message #21, redelivered = false, ack-ed
[consumer2] Received Message #22, redelivered = false, ack-ed
[consumer2] Received Message #23, redelivered = false, ack-ed
[consumer2] Received Message #24, redelivered = false, ack-ed
[consumer2] Received Message #25, redelivered = false, ack-ed
[consumer2] Received Message #26, redelivered = false, ack-ed
[consumer2] Received Message #27, redelivered = false, ack-ed
[consumer2] Received Message #28, redelivered = false, ack-ed
[consumer2] Received Message #29, redelivered = false, ack-ed
[consumer2] Received Message #30, redelivered = false, ack-ed
[consumer2] Received Message #31, redelivered = false, ack-ed
[consumer2] Received Message #32, redelivered = false, ack-ed
[consumer2] Received Message #33, redelivered = false, ack-ed
[consumer2] Received Message #34, redelivered = false, ack-ed
[consumer2] Received Message #35, redelivered = false, ack-ed
</pre>

As we can see, consumer #1 did not acknowledge 3 messages (labelled 1, 2 and 5):

<pre>
[consumer1] Got message #1, SKIPPPED
[consumer1] Got message #2, SKIPPPED
...
[consumer1] Got message #5, SKIPPPED
</pre>

and then, once consumer #1 had "crashed", those messages were immediately redelivered to the consumer #2:

<pre>
Connection 1 is now closed (we pretend that it has crashed)
[consumer2] Received Message #5, redelivered = true, ack-ed
[consumer2] Received Message #1, redelivered = true, ack-ed
[consumer2] Received Message #2, redelivered = true, ack-ed
</pre>

To acknowledge a message, use {AMQP::Channel#acknowledge}:

<pre>
<code>
channel1.acknowledge(metadata.delivery_tag, false)
</code>
</pre>

{AMQP::Channel#acknowledge} takes two arguments: message *delivery tag* and a flag that indicates whether or not we acknowledge
multiple messages at once. Delivery tag is simply a channel-specific increasing number that server uses to identify deliveries.

When acknowledging multiple messages at once, the delivery tag is treated as "up to and including". For example, for delivery
tag = 5 that would mean "acknowledge messages 1, 2, 3, 4 and 5".

As a shortcut, it is possible to acknowledge messages using {AMQP::Header#ack} method:

<pre>
<code>
queue2.subscribe(:ack => true) do |metadata, payload|
  metadata.ack
end
</code>
</pre>

<span class="note">
Acknowledgements are channel-specific. Applications must not receive messages on one channel and acknowledge them on another channel.
</span>

<span class="note">
A message MUST not be acknowledged more than once. Doing so will result in a channel-level exception (PRECONDITION_FAILED)
with an error message like this: «PRECONDITION_FAILED - unknown delivery tag»
</span>



h3. Rejecting messages.

When a consumer application receives a message, processing of that message may or may not succeed. Application can
indicate it to the broker that message processing has failed (or cannot be accomplished at the time) by rejecting a message.
While rejecting a message, application can ask broker to discard or requeue it.

To reject a message, use {AMQP::Channel#reject} method:

<pre>
<code>
queue.bind(exchange).subscribe do |metadata, payload|
  # reject but don't requeue (simply discard)
  channel.reject(metadata.delivery_tag)
end
</code>
</pre>

in the example above messages are rejected without requeueing (broker will simply discard them). To requeue rejected message,
use the second argument {AMQP::Channel#reject} takes:

<pre>
<code>
queue.bind(exchange).subscribe do |metadata, payload|
  # reject & requeue
  channel.reject(metadata.delivery_tag, true)
end
</code>
</pre>

<span class="note">
When there is only one consumer on a queue, make sure you don't create infinite message delivery loops by rejecting & requeueing
message from that consumer over and over.
</span>

Another way to reject a message is by using {AMQP::Header#reject}:

<pre>
<code>
queue.bind(exchange).subscribe do |metadata, payload|
  # reject but don't requeue (simply discard)
  metadata.reject
end
</code>
</pre>

<pre>
<code>
queue.bind(exchange).subscribe do |metadata, payload|
  # reject & requeue
  metadata.reject(true)
end
</code>
</pre>


h3. Negative acknowledgements.

Messages are rejected with `basic.reject` AMQP method. There is one limitation `basic.reject` has: there is no way to reject multiple
messages, like you can do with acknowledgements. If you are using "RabbitMQ":http://rabbitmq.com, there is a solution: RabbitMQ provides
an AMQP 0.9.1 extension known as "negative acknowledgements":http://www.rabbitmq.com/extensions.html#negative-acknowledgements (nacks) and
amqp gem supports it. For more information, please refer to the {file:docs/VendorSpecificExtensions.textile Vendor-specific Extensions guide}.


h3. QoS. Prefetching messages.

For cases when multiple consumers share a queue, it is useful to be able to specify how many messages each consumer can be sent at once
(before sending the next acknowledgement). This can be used as a simple load balancing technique or to improve throughput if messages tend
to be published in batches (for example, if producing application sends them every minute because of the nature of the work it is doing).

Imagine a Website that takes data from social media sources like Twitter or Facebook during the Champions League final (or the Superbowl), and then
calculates how many tweets mentioned a particular team over the last minute. It can be structured as 3 applications:

 * A crawler that uses streaming APIs to fetch tweets/statuses, normalizes them and sends them in JSON for processing by other applications ("app A").
 * A calculator that detects what team is mentioned in a message, updates statistics and pushes an update to the Web UI once a minute ("app B").
 * A Web UI that fans visit to see the stats ("app C").

In this imaginary example, tweets per second rate will vary but to improve throughput of the system and decrease maximum number of messages AMQP broker
has to hold in memory at once, applications can be designed in such a way that application "app B", the "calculator", receives 5000 messages and then
acknowledges them all at once. Broker will not send message 5001 to it unless it receives an acknowledgement for #1, either individually or in bulk
with other messages.

In AMQP parlance this is know as *QoS* or *message prefetching*. Prefetching is configured on per-channel (typically) or per-connection (rarely used)
basis. To configure prefetching per channel, use {AMQP::Channel#prefetch} method. Lets come back to the example we used in the "Message acknowledgements"
section:

<pre>
<code>
# first app will be given up to 3 messages at a time. If it doesn't
# ack any messages after it was delivered 3, messages will be routed to
# the app #2.
channel1.prefetch(3)

# app #2 processes messages one-by-one and has to send and ack every time
channel2.prefetch(1)
</code>
</pre>

In that example, one consumer prefetches 3 messages and another consumer prefetches just 1. If we take a look at the output that example produces,
we will see that `consumer1` fetched 4 messages and acknowledged 1. After that, all subsequent messages were delivered to the `consumer2`:

<pre>
[consumer2] Received Message #0, redelivered = false, ack-ed
[consumer1] Got message #1, SKIPPPED
[consumer1] Got message #2, SKIPPPED
[consumer1] Got message #3, ack-ed
[consumer2] Received Message #4, redelivered = false, ack-ed
[consumer1] Got message #5, SKIPPPED
---
  by now consumer 1 has received 3 messages it did not acknowledge.
  With prefetch = 3, AMQP broker won't send it any more messages until consumer 1 sends an ack
---
[consumer2] Received Message #6, redelivered = false, ack-ed
[consumer2] Received Message #7, redelivered = false, ack-ed
[consumer2] Received Message #8, redelivered = false, ack-ed
[consumer2] Received Message #9, redelivered = false, ack-ed
[consumer2] Received Message #10, redelivered = false, ack-ed
[consumer2] Received Message #11, redelivered = false, ack-ed
</pre>

<span class="note">
Prefetching setting is ignored for consumers that do not use explicit acknowledgements
</span>


h2. Relation of message acknowledgements to transactions and Publisher Confirms.

In cases when not a single message may be lost, AMQP 0.9.1 applications can use one (or combination of) the following protocol features:

 * Publisher confirms (a RabbitMQ-specific extension to AMQP 0.9.1)
 * Publishing messages as immediate
 * Transactions (noticeable overhead)

This topic is covered in depth in the {file:docs/Exchanges.textile Working With Exchanges} guide.
In this guide, we will only mention how message acknowledgements are related to AMQP transactions and Publisher Confirms extension.
Lets consider a publisher application P that communications with a consumer C using AMQP 0.9.1. Their communication can be graphically
represented like this:

<pre>
-----       -----       -----
|   |   S1  |   |   S2  |   |
| P | ====> | B | ====> | C |
|   |       |   |       |   |
-----       -----       -----
</pre>

We have two network segments, S1 and S2. Each of them may fail. Application P is concerned with making sure that messages cross S1,
while broker and application C are concerned with the fact that messages cross S2 and are only removed from the queue when
they are processed successfully.

Message acknowledgements cover reliable delivery over S2 and successful processing. For S1, P has to use transactions (a heavyweight solution) or
lightweight Publisher Confirms, a RabbitMQ-specific extension.




h2. Fetching messages when needed ("pull API")

AMQP 0.9.1 also provides a way for applications to fetch (pull) messages from the queue only when necessary. For that, use
{AMQP::Queue#pop}:

<pre>
<code>
queue.pop do |metadata, payload|
  if payload
    puts "Fetched a message: #{payload.inspect}, content_type: #{metadata.content_type}. Shutting down..."
  else
    puts "No messages in the queue"
  end
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/998732.js"> </script>

If queue is empty, `payload` argument will be nil, otherwise arguments are identical to those of {AMQP::Queue#subscribe}
callback.


h2. Unsubscribing from messages

Sometimes it is necessary to unsubscribe from messages without deleting a queue. To do that, use {AMQP::Queue#unsubscribe} method:

<pre>
<code>
queue.unsubscribe
</code>
</pre>

By default {AMQP::Queue#unsubscribe} uses :noack option to inform broker that there is no need to send a
confirmation. In other words, it does not expect you to pass in a callback, because consumer tag on the queue instance and registered
callback for messages are cleared immediately.

If application needs to execute a piece of code after broker response arrives, {AMQP::Queue#unsubscribe} takes an
optional callback:

<pre>
<code>
queue.unsubscribe do |unbind_ok|
  # server response arrived, handle it if necessary...
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/998734.js"> </script>

In AMQP parlance, unsubscribing from messages is often referred to as "cancelling a consumer". Once consumer is cancelled,
messages will no longer be delivered to it, however, due to the asynchronous nature of the protocol, it is possible for
“in flight” messages to be received after this call completes.

Fetching messages with {AMQP::Queue#pop} is still possible even after consumer is cancelled.


h2. Unbinding queues from exchanges

To unbind queue from exchange, use {AMQP::Queue#unbind}:

<pre>
<code>
queue.unbind(exchange)
</code>
</pre>

Full example:
<script src="https://gist.github.com/998742.js"> </script>

Note that unbinding an exchange queue was never bound to will result in a channel-level exception.


h2. Getting number of messages in the queue

It is possible to get number of messages sitting in the queue by declaring it with :passive attribute set.
The response (queue.declare-ok AMQP method) will carry number of messages among other attributes. However,
amqp gem provides a convenience method, {AMQP::Queue#status}:

<pre>
<code>
queue.status do |number_of_messages, number_of_consumers|
  puts
  puts "# of messages in the queue #{queue.name} = #{number_of_messages}"
  puts
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/1068363.js"> </script>



h2. Getting number of consumers on the queue

It is possible to get number of consumers on the queue by declaring it with :passive attribute set.
The response (queue.declare-ok AMQP method) will carry number of messages among other attributes. However,
amqp gem provides a convenience method, {AMQP::Queue#status}:

<pre>
<code>
queue.status do |number_of_messages, number_of_consumers|
  puts
  puts "# of consumers on the queue #{queue.name} = #{number_of_consumers}"
  puts
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/1068377.js"> </script>



h2. Purging queues

It is possible to purge a queue (remove all messages from it) using {AMQP::Queue#purge}:

<pre>
<code>
queue.purge
</code>
</pre>

This method takes a callback but it is optional. However, remember that this operation is performed asynchronously.
To run a piece of code when AMQP broker confirms that queue has been purged, use a callback {AMQP::Queue#purge} takes:

<pre>
<code>
queue.purge do |_|
  puts "Purged #{queue.name}"
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/998743.js"> </script>

Note that this example purges a newly declared queue with unique server-generated name. When queue is declared,
it is empty, so for server-named queues, there is no need to purge them before application can use it.


h2. Deleting queues

To delete a queue, use {AMQP::Queue#delete}. When queue is deleted, all the messages in it are deleted as well.

<pre>
<code>
queue.delete
</code>
</pre>

This method takes a callback but it is optional. However, remember that this operation is performed asynchronously.
To run a piece of code when AMQP broker confirms that queue has been deleted, use a callback {AMQP::Queue#delete} takes:

<pre>
<code>
queue.delete do |_|
  puts "Deleted #{queue.name}"
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/998744.js"> </script>



h2. Objects as message consumers. Unit testing consumers in isolation.

Since Ruby is a genuine object-oriented language, it is important to demonstrate how Ruby amqp gem can be integrated
into rich object-oriented code. This guide focuses on queues and problems/solutions consumer applications
(apps that primarily receive and process messages, as opposed to producers that publish them).

{AMQP::Queue#subscribe} callback doesn't have to be a block: it can be any Ruby object that responds to `call`.
A common technique is to combine {http://rubydoc.info/stdlib/core/1.8.7/Object:method Object#method} and {http://rubydoc.info/stdlib/core/1.8.7/Method:to_proc Method#to_proc}
and use object methods as message handlers.

An example to demonstrate this technique:

<pre>
<code>
class Consumer

  #
  # API
  #

  def initialize(channel, queue_name = AMQ::Protocol::EMPTY_STRING)
    @queue_name = queue_name

    @channel    = channel
    # Consumer#handle_channel_exception will handle channel
    # exceptions. Keep in mind that you can only register one error handler,
    # so the last one registered "wins".
    @channel.on_error(&method(:handle_channel_exception))
  end # initialize

  def start
    @queue = @channel.queue(@queue_name, :exclusive => true)
    # #handle_message method will be handling messages routed to @queue
    @queue.subscribe(&method(:handle_message))
  end # start



  #
  # Implementation
  #

  def handle_message(metadata, payload)
    puts "Received a message: #{payload}, content_type = #{metadata.content_type}"
  end # handle_message(metadata, payload)

  def handle_channel_exception(channel, channel_close)
    puts "Oops... a channel-level exception: code = #{channel_close.reply_code}, message = #{channel_close.reply_text}"
  end # handle_channel_exception(channel, channel_close)
end
</code>
</pre>

Full example:

<script src="https://gist.github.com/1009425.js"> </script>


In this example, `Consumer` instances have to be instantiated with an {AMQP::Channel} instances. If message handling was done
by an aggregated object, it would make handling logic completely separated from the rest and will be easy to unit test
in isolation:

<pre>
<code>
class Consumer

  #
  # API
  #

  def handle_message(metadata, payload)
    puts "Received a message: #{payload}, content_type = #{metadata.content_type}"
  end # handle_message(metadata, payload)
end


class Worker

  #
  # API
  #


  def initialize(channel, queue_name = AMQ::Protocol::EMPTY_STRING, consumer = Consumer.new)
    @queue_name = queue_name

    @channel    = channel
    @channel.on_error(&method(:handle_channel_exception))

    @consumer   = consumer
  end # initialize

  def start
    @queue = @channel.queue(@queue_name, :exclusive => true)
    @queue.subscribe(&@consumer.method(:handle_message))
  end # start



  #
  # Implementation
  #

  def handle_channel_exception(channel, channel_close)
    puts "Oops... a channel-level exception: code = #{channel_close.reply_code}, message = #{channel_close.reply_text}"
  end # handle_channel_exception(channel, channel_close)
end
</code>
</pre>

Full example:
<script src="https://gist.github.com/1009447.js"> </script>


Note that `Consumer` class demonstrated above can be easily tested in isolation, without spinning up any AMQP connections:

<pre>
<code>
require "ostruct"
require "json"

# RSpec example
describe Consumer do
  describe "when a new message arrives" do
    subject { described_class.new }

    let(:metadata) do
      o = OpenStruct.new

      o.content_type = "application/json"
      o
    end
    let(:payload)  { JSON.encode({ :command => "reload_config" }) }

    it "does some useful work" do
      # check preconditions here if necessary

      subject.handle_message(metadata, payload)

      # add your code expectations here
    end
  end
end
</code>
</pre>

TBD



h2. Queue durability vs Message durability

See {file:docs/Durability.textile Durability guide}



h2. Error handling and recovery

See {file:docs/ErrorHandling.textile Error handling and recovery guide}



h2. Vendor-specific extensions related to queues

See {file:docs/VendorSpecificExtensions.textile Vendor-specific Extensions guide}



h2.  What to read next

Documentation is organized as several {file:docs/DocumentationGuidesIndex.textile documentation guides}, covering all kinds of
topics. Guides related to this one are

 * {file:docs/Exchanges.textile Working With Exchanges}
 * {file:docs/Bindings.textile Bindings}
 * {file:docs/ErrorHandling.textile Error handling and recovery}

RabbitMQ implements a number of extensions to AMQP 0.9.1 functionality, covered in the {file:docs/VendorSpecificExtensions.textile Vendor-specific Extensions guide}.
At least one extension, per-queue messages time-to-live (TTL), is related to this guide and can be used with amqp gem 0.8.0 and later.



h2. Tell us what you think!

Please take a moment and tell us what you think about this guide "on Twitter":http://twitter.com/rubyamqp or "Ruby AMQP mailing list":http://groups.google.com/group/ruby-amqp:
what was unclear? what wasn't covered? maybe you don't like guide style or grammar and spelling are incorrect? Readers feedback is
key to making documentation better.

If mailing list communication is not an option for you for some reason, you can "contact guides author directly":mailto:michael@novemberain.com?subject=amqp%20gem%20documentation


<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'rubyamqpdocs'; // required: replace example with your forum shortname

    var disqus_developer = 0; // set to 1 on local machine for testing comments
    var disqus_identifier = 'amqp_queues';
    var disqus_url = 'http://rdoc.info/github/ruby-amqp/amqp/master/file/docs/Queues.textile';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
