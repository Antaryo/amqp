# @title Ruby AMQP gem: Working with exchanges

h1. Working with exchanges


h2. About this guide

This guide covers exchanges in AMQP 0.9.1, message publishing, common usage scenarios and how to accomplish typical operations using
Ruby amqp gem.


h2. Covered versions

This guide covers "Ruby amqp gem":http://github.com/ruby-amqp/amqp v0.8.0 and later.


h2. Exchanges in AMQP 0.9.1, briefly

h3. What are AMQP exchanges?

An exchange accepts messages from a producer application and routes these to message queues. They can be thought of as "mailboxes" of AMQP
world. Unlike some other messaging middleware products and protocols, in AMQP messages are *not* published directly to queues: they
are published to exchanges that route them to queue(s) using pre-arranged criteria (called bindings).

There are multiple exchange types in AMQP 0.9.1, each with its own routing semantics. Custom exchange types can be created to cover
sophisticated routing scenarios (for example, routing based on geolocation data), edge cases or just for convenience.


h3. Concept of bindings

Binding is an association between a queue and an exchange. Queues must be bound to at least one exchange in order to receive messages from publishers.
Learn more about bindings in {file:docs/Bindings.textile Bindings guide}.


h3. Attributes

Exchanges have several attributes associated with them:

 * Name
 * Type (direct, fanout, topic, headers or some custom type)
 * Durability
 * Whether exchange is auto-deleted when no longer used
 * Other metadata (aka X-arguments)


h2. Exchange types

There are 4 built-in exchange types in AMQP 0.9.1:

 * Direct
 * Fanout
 * Topic
 * Headers

As stated previously, each exchange type has own routing semantics and new exchange types can be added by extending brokers with plugins.
Custom exchange types begin with x-, much like custom HTTP headers, for example, "x-recent-history exchange":https://github.com/videlalvaro/rabbitmq-recent-history-exchange
or "x-random exchange":https://github.com/jbrisbin/random-exchange.




h2. Message attributes

Before we start looking at various exchange types and their routing semantics, we need to introduce idea of message attributes.
Every AMQP message has a number of *attributes*. Some attributes are important and used very often, other are used rarely. AMQP message attributes are metadata:
they are similar in purpose to HTTP request and response headers.

Every AMQP 0.9.1 message has an attribute called the *routing key*. The routing key is an "address" that the exchange may use to decide how to route
the message (similar to, but more generic, than URL in HTTP). Most exchange types use routing key to implement routing logic, but some ignore
it and use other criteria (for example, message content).




h2. Fanout exchanges

h3. How fanout exchange routes messages

Fanout exchanges route messages to all queues bound to it, the routing key is ignored. If N queues are bound to a fanout exchange,
when a new message is published to that exchange, a *copy of the message* is delivered to all N queues, so fanout exchanges
are ideal for "broadcast routing":http://en.wikipedia.org/wiki/Broadcasting_%28computing%29 of messages.

Graphically this can be represented as

!http://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/500px-Broadcast.svg.png!


h3. Declaring a fanout exchange

There are two ways to declare a fanout exchange: using by instantiating {AMQP::Exchange} and specifying type as `:fanout`, or
with {AMQP::Channel#fanout}. Two examples to demonstrate:

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :fanout, "nodes.metadata")
</code>
</pre>

<pre>
<code>
exchange = channel.fanout("nodes.metadata")
</code>
</pre>

Both methods asynchronously declare a queue. Because declaration takes a network roundtrip, publishing operations on {AMQP::Exchange} instances are
delayed until broker reply (exchange.declare-ok) is received.


Both methods let you pass a block to run a piece of code when broker responds with exchange.declare-ok (meaning exchange is successfully declared).

<pre>
<code>
channel.fanout("nodes.metadata") do |exchange|
  # exchange is declared and ready to be used.
end
</code>
</pre>

h3. Routing example

To demonstrate this routing behavior, we can declare 10 server-named exclusive queues and bind them all to one fanout exchange,
then publish a message there:

<pre>
<code>
exchange = channel.topic("amqpgem.examples.routing.fanout_routing", :auto_delete => true)

10.times do
  q = channel.queue("", :exclusive => true, :auto_delete => true).bind(exchange)
  q.subscribe do |payload|
    puts "Queue #{q.name} received #{payload}"
  end
end
</code>
</pre>

<pre>
<code>
# Publish some test data in a bit, after all queues are declared & bound
EventMachine.add_timer(1.2) { exchange.publish "Hello, fanout exchanges world!" }
</code>
</pre>

When run, this example produces the following output:

<pre>
Queue amq.gen-0p/BjxGNCue42RcJhpUrdg== received Hello, fanout exchanges world!
Queue amq.gen-3GXULvZuYh1KsOD83yvlNg== received Hello, fanout exchanges world!
Queue amq.gen-4EcyydTfoZzXjNSSLsh09Q== received Hello, fanout exchanges world!
Queue amq.gen-B1isyTpR5svB6ClQ2TQEBQ== received Hello, fanout exchanges world!
Queue amq.gen-FwLLioB7Mk4LGA4yJ1Mo7A== received Hello, fanout exchanges world!
Queue amq.gen-OtBQokiA/DmNkB5bPzaRig== received Hello, fanout exchanges world!
Queue amq.gen-RYHQUrj3yihb0DRF7KVpRg== received Hello, fanout exchanges world!
Queue amq.gen-SZJ40mGwbhdcbOGeHMhUkg== received Hello, fanout exchanges world!
Queue amq.gen-sDeVZg9Vx1knq+n9EMi8tA== received Hello, fanout exchanges world!
Queue amq.gen-uWOuVaosW4bWAHqKG6pZVw== received Hello, fanout exchanges world!
</pre>

All the queues bound to the exchange receives a *copy* of the message.


Full example:
<script src="https://gist.github.com/1020181.js"> </script>


h3. Use cases

Because fanout exchanges deliver a copy of a message to every queue bound to it, use cases for it are quite similar:

 * MMO games can use it for leaderbard updates or other global events.
 * Sport news sites can use fanout exchanges for distributing score updates to mobile clients in near real-time.
 * Distributed systems can broadcast various state and configuration updates.
 * Group chats can distribute messages between participants using a fanout exchange (although AMQP doesn't have built-in concept of presence, so "XMPP":http://xmpp.org may be a better choice)


h3. Pre-declared fanout exchanges

AMQP 0.9.1 brokers must implement fanout exchange type and pre-declare one instance with the name of "amq.fanout".
This means that applications can rely on that exchange to always be available to them. Each vhost has a separate instance of that exchange,
it is *not shared across vhosts* for obvious reasons.

TBD




h2. Direct exchanges

Direct exchange delivers messages to queues based on *message routing key*, an attribute every AMQP 0.9.1 message has.

Here is how it works:

 * A queue binds to the exchange with a routing key, K.
 * When a new message with routing key R arrives to direct exchange, the exchange routes it to the queue if K = R.

Direct exchange is ideal for "unicast routing":http://en.wikipedia.org/wiki/Unicast of messages (although it can be used for "multicast routing":http://en.wikipedia.org/wiki/Multicast, too).

!http://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Unicast.svg/500px-Unicast.svg.png!


There are two ways to declare a direct exchange: using by instantiating {AMQP::Exchange} and specifying type as `:direct`, or
with {AMQP::Channel#direct}. Two examples to demonstrate:

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :direct, "nodes.metadata")
</code>
</pre>

<pre>
<code>
exchange = channel.direct("nodes.metadata")
</code>
</pre>

Both methods asynchronously declare a queue. Because declaration takes a network roundtrip, publishing operations on {AMQP::Exchange} instances are
delayed until broker reply (exchange.declare-ok) is received.


Both methods let you pass a block to run a piece of code when broker responds with exchange.declare-ok (meaning exchange is successfully declared).

<pre>
<code>
channel.direct("pages.content.extraction") do |exchange|
  # exchange is declared and ready to be used.
end
</code>
</pre>


h3. Routing example

TBD


h3. Use cases

TBD


h3. Pre-declared direct exchanges

AMQP 0.9.1 brokers must implement direct exchange type and pre-declare two instances

 * *amq.direct*.
 * *""* (unnamed, referred to as an empty string by many clients including amqp Ruby gem) exchange known as *default exchange*.

This means that applications can rely on those exchanges to always be available to them. Each vhost has separate instances of those exchanges,
they are *not shared across vhosts* for obvious reasons.


h3. Default exchange

Default exchange is a direct exchange with no name (amqp gem refers to it using an empty string) pre-declared by the broker. It has one key special
property that makes it very useful for simple applications: *every queue is automatically bound to it with a routing key the same as queue name".

For example, when you declare a queue with the name of "search.indexing.online", AMQP broker will bind it to the default exchange using
"search.indexing.online" as routing key. So a message publishes to the default exchange with routing key = "search.indexing.online"
will be routed to the queue "search.indexing.online". In other words, default exchange makes it possible to "deliver messages directly to queues",
even though that is not technically correct.


amqp gem offers two ways of obtaining of the default exchange: {AMQP::Channel#default_exchange} and {AMQP::Channel#direct} (use  empty string as exchange name).
{AMQP::Exchange#initialize} can be used as well but requires more effort and for this particular case offers no benefits over instance methods on {AMQP::Channel}.

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :direct, "")
</code>
</pre>

<pre>
<code>
exchange = channel.default_exchange
</code>
</pre>

<pre>
<code>
exchange = channel.direct("")
</code>
</pre>



The default exchange is what the "Hello, World" example uses:

{include:file:examples/hello_world.rb}



h2. Topic exchanges

Topic exchanges route messages to one or many queues based on matching between message routing key and pattern that was used for binding
queue to the exchange. This exchange type is often used to implement various "publish/subscribe pattern":http://en.wikipedia.org/wiki/Publish/subscribe variations.


Topic exchanges are commonly used for "multicast routing":http://en.wikipedia.org/wiki/Multicast of messages.

!http://upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/500px-Multicast.svg.png!

Topic exchanges can be used for "broadcast routing":http://en.wikipedia.org/wiki/Broadcasting_%28computing%29 but usually fanout exchanges are more efficient at that.


h3. Routing example

Two classic examples of topic-based routing are stocks price updates and location-specific data (for instance, weather broadcasts).
Consumers indicate what topics they are interested in (think of it as of subscribing to a feed for individual tag
of your favourite blog as opposed to full feed). They do it by specifying a _routing pattern_ on binding, for example:

<pre>
<code>
channel.queue("americas.south").bind(exchange, :routing_key => "americas.south.#").subscribe do |headers, payload|
  puts "An update for South America: #{payload}, routing key is #{headers.routing_key}"
end
</code>
</pre>

In the example above we bind a queue with the name of "americas.south" to the topic exchange declared earlier using {AMQP::Queue#bind} method.
This means that only messages with routing key matching americas.south.# will be routed to that queue. Routing pattern consists of several words
separated by dots, similarly to URI path segments joined by slash. A few of examples:

 * asia.southeast.thailand.bangkok
 * sports.basketball
 * usa.nasdaq.aapl
 * tasks.search.indexing.accounts

The following routing keys do match "americas.south.#" pattern:

 * americas.south
 * americas.south.*brazil*
 * americas.south.*brazil.saopaolo*
 * americas.south.*chile.santiago*

In other words, # part of the pattern matches 0 or more words. For "americas.south.*", some of matching routing keys are

 * americas.south.*brazil*
 * americas.south.*chile*
 * americas.south.*peru*

but not

 * americas.south
 * americas.south.chile.santiago


Full example:
<script src="https://gist.github.com/1020308.js"> </script>


h3. Use cases

TBD



h2. Headers exchanges

Headers exchanges route messages based on message header matching. Header exchanges ignore routing key attribute. The best way
to explain headers-based routing is with an example.


h3. Routing example


TBD


h3. Use cases

TBD


h3. Pre-declared headers exchanges

TBD




h2. Custom exchange types

h3. x-random

"x-random AMQP exchange type":https://github.com/jbrisbin/random-exchange is a custom exchange type developed as a
RabbitMQ plugin by Jon Brisbin. To quote project README:

bq. It is basically a direct exchange, with the exception that, instead of each consumer bound to that exchange with the
    same routing key getting a copy of the message, the exchange type randomly selects a queue to route to.

This plugin is licensed under "Mozilla Public License 1.1":http://www.mozilla.org/MPL/MPL-1.1.html, same as RabbitMQ.

h3. x-recent-history

"x-recent-history AMQP exchange type":https://github.com/videlalvaro/rabbitmq-recent-history-exchange is a customer exchange type
implemented as a RabbitMQ plugin by Alvaro Videla, one of the authors of "RabbitMQ in action":http://bit.ly/rabbitmq.

This plugin is licensed under the "MIT license":https://github.com/videlalvaro/rabbitmq-recent-history-exchange/blob/master/LICENSE.md.


h2. Declaring/Instantiating exchanges

With Ruby AMQP gem, exchanges can be declared two ways: using {AMQP::Exchange#initialize} method that takes an optional callback or
with a number of convenience methods on {AMQP::Channel} instances:

 * {AMQP::Channel#direct}
 * {AMQP::Channel#default_exchange}
 * {AMQP::Channel#topic}
 * {AMQP::Channel#fanout}
 * {AMQP::Channel#headers}

Sections on specific exchange types (direct, fanout, headers, etc) provide plenty of examples of how these methods can be used.



h2. Publishing messages


h3. Publishing one-off messages

The following example publishes a message and *safely* closes AMQP connection after that by passing a block
to {AMQP::Exchange#publish}:

{include:file:examples/publishing/publishing_a_one_off_message.rb}

TBD



h2. Binding queues to exchanges

Queues are bound to exchanges using {AMQP::Queue#bind} method. This topic is described in detail in the {file:docs/Queues.textile Working with queues}
documentation guide.



h2. Unbinding queues from exchanges

Queues are unbound from exchanges using {AMQP::Queue#unbind} method. This topic is described in detail in the {file:docs/Queues.textile Working with queues}
documentation guide.


h2. Deleting exchange

h3. Explicitly deleting an exchange

Exchanges are deleted using {AMQP::Exchange#delete} method:

<pre>
<code>
exchange.delete
</code>
</pre>

{AMQP::Exchange#delete} takes an optional callback that is run when `exchange.delete-ok` arrives from the broker.

<pre>
<code>
exchange.delete do |delete_ok|
  # by now exchange is guaranteed to be deleted
end
</code>
</pre>

h3. Auto-deleted exchanges

Exchanges are be *auto-deleted*. To declare an exchange as auto-deleted, use :auto_delete option on declaration:

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :direct, "nodes.metadata", :auto_delete => true)
</code>
</pre>

<pre>
<code>
exchange = channel.direct("nodes.metadata", :auto_delete => true)
</code>
</pre>


Full example:
<script src="https://gist.github.com/1020226.js"> </script>

TBD: explain when exchange is considered to be "no longer in use"


h2. Objects as message producers.

Since Ruby is a genuine object-oriented language, it is important to demonstrate how Ruby amqp gem can be integrated
into rich object-oriented code. This guide focuses on exchanges and problems/solutions producer applications
(apps that primarily generate and publish messages, as opposed to consumers that receive and process them).

Full example:
<script src="https://gist.github.com/1009425.js"> </script>

TBD



h2. Exchange durability vs Message durability

See {file:docs/Durability.textile Durability guide}



h2. Error handling and recovery

See {file:docs/ErrorHandling.textile Error handling and recovery guide}



h2. Vendor-specific extensions related to exchanges

See {file:docs/VendorSpecificExtensions.textile Vendor-specific Extensions guide}



h2.  What to read next

Documentation is organized as several {file:docs/DocumentationGuidesIndex.textile documentation guides}, covering all kinds of
topics. Guides related to this one are

 * {file:docs/Durability.textile Durability and message persistence}
 * {file:docs/Bindings.textile Bindings}
 * {file:docs/Routing.textile Routing}
 * {file:docs/Queues.textile Working With Queues}
 * {file:docs/ErrorHandling.textile Error handling and recovery}




h2. Tell us what you think!

Please take a moment and tell us what you think about this guide on "Ruby AMQP mailing list":http://groups.google.com/group/ruby-amqp:
what was unclear? what wasn't covered? maybe you don't like guide style or grammar and spelling are incorrect? Readers feedback is
key to making documentation better.

If mailing list communication is not an option for you for some reason, you can "contact guides author directly":mailto:michael@novemberain.com?subject=amqp%20gem%20documentation


<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'rubyamqpdocs'; // required: replace example with your forum shortname

    var disqus_developer = 0; // set to 1 on local machine for testing comments
    var disqus_identifier = 'amqp_exchanges';
    var disqus_url = 'http://rdoc.info/github/ruby-amqp/amqp/master/file/docs/Exchanges.textile';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
